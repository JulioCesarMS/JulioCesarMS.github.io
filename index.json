
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    [{"authors":null,"categories":null,"content":"Julio Cesar Martinez is passionate about statistics, stochastic processes and data science.\n","date":1554595200,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":1554595200,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"","publishdate":"0001-01-01T00:00:00Z","relpermalink":"","section":"authors","summary":"Julio Cesar Martinez is passionate about statistics, stochastic processes and data science.","tags":null,"title":"Julio Cesar Martinez","type":"authors"},{"authors":[],"categories":null,"content":" Click on the Slides button above to view the built-in slides feature. Slides can be added in a few ways:\nCreate slides using Wowchemy’s Slides feature and link using slides parameter in the front matter of the talk file Upload an existing slide deck to static/ and link using url_slides parameter in the front matter of the talk file Embed your slides (e.g. Google Slides) or presentation video on this page using shortcodes. Further event details, including page elements such as image galleries, can be added to the body of this page.\n","date":1906549200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1906549200,"objectID":"a8edef490afe42206247b6ac05657af0","permalink":"https://example.com/talk/example-talk/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/talk/example-talk/","section":"event","summary":"An example talk using Wowchemy's Markdown slides feature.","tags":[],"title":"Example Talk","type":"event"},{"authors":null,"categories":["Python"],"content":"Introducción La matriz de confusión se utiliza como indicador en temas de clasificación. Contiene el número de elementos que se han sido clasificados correcta o incorrectamente para cada clase. En su diagonal diagonal principal el número de observaciones correctamente clasificadas para cada clase, los elementos no diagonales indican el número de observaciones incorrectamente clasificadas. Una de las ventajas de una matriz de confusión es que es fácil ver si el un modelo u algoritmo confunde dos clases.\nLa matriz de confusión puede aplicarse tanto a la clasificación binaria como a los problemas de clasificación multiclase. La salida TN significa Verdadero Negativo y muestra el número de ejemplos negativos clasificados con precisión. Del mismo modo, TP significa Verdadero Positivo, que indica el número de ejemplos positivos clasificados con precisión. El término FP muestra el valor Falso Positivo, es decir, el número de ejemplos negativos reales clasificados como positivos; y FN significa un valor Falso Negativo que es el número de ejemplos positivos reales clasificados como negativos.\nLa matriz de confusión consta de cuatro características básicas (números) que se utilizan para definir la métrica de medición del clasificador. Estos cuatro números son:\nTP (Verdadero Positivo): Por ejempo, TP representa el número de ejemplos que se ha clasificado como positivos cuando son positivos.\nTN (Verdadero Negativo): TN representa el número de ejemplos clasificados como negativos cuando en realidad lo son.\nFP (Falso Positivo): FP representa el número de ejemplos clasificados erróneamente como positivos cuando en realidad son negativos. FP también se conoce como error de tipo I.\nFN (Falso Negativo): FN representa el número de ejemplos clasificados erróneamente como negativos cuando en realidad son positivos. FN también se conoce como error de tipo II.\nDe la matriz de confusión se pueden definir las siguientes métricas: Las métricas de rendimiento de un algoritmo son: accuracy, precision, recall, y el F1 score, que se calculan a partir de los valores TP, TN, FP y FN mencionados anteriormente.\nAccuracy El accuracy se representa como la relación entre ejemplos clasificados correctamente (TP+TN) y el número total de ejemplos (TP+TN+FP+FN).\n$$\\begin{equation}\rAccuracy = \\frac{(TP + TN)}{(TP + FP + FN + TN)}\r\\end{equation}$$\nPrecision La precisión se representa como la relación entre ejemplos correctamente clasificados positivos (TP) y el total de pacientes a los que se predice como positivos (TP+FP). Mide que tan preciso es un modelo entre los predichos positivos.\n$$\\begin{equation}\rPrecision = \\frac{(TP)}{(TP + FP)}\r\\end{equation}$$\nRecall La métrica recall se define como la proporción de ejemplos correctamente clasificados (TP) dividida por el número total de ejemplos que tienen realmente son positivos.\n$$\\begin{equation}\rRecall = \\frac{(TP)}{(TP + FN)}\r\\end{equation}$$\nEl Recall es también conocido como sensitivity.\nF1 score La métrica \\(F1 \\ score\\) también se conoce como \\(F\\ measure\\). La métrica \\(F1\\ score\\) establece el equilibrio entre la precision y recall. En términos prácticos esta medida busca un balance entre precision y recall.\n$$\\begin{equation}\rF1\\ score = 2 \\times \\frac{Precision \\times Recall}{Precision + Recall}\r\\end{equation}$$\nEjemplo: Breast Cancer dataset Descripción del conjunto de datos Las características se obtivieron a partir de una imagen digitalizada de un aspirado con aguja fina (AAF) de una masa mamaria.\nEl plano de separación descrito anteriormente se obtuvo mediante el método Multisurface Method-Tree (MSM-T). Las características relevantes se seleccionaron mediante una búsqueda exhaustiva en el espacio de 1-4 características y 1-3 planos de separación.\nAtributos:\nradio (media de las distancias del centro a los puntos del perómetro) textura (desviación estándar de los valores de la escala de grises) perímetro área suavidad (variación local de las longitudes de los radios) compacidad ($perímetro^2$ / área - 1) concavidad (gravedad de las partes cóncavas del contorno) puntos cóncavos (número de porciones cóncavas del contorno) simetría dimensión fractal (“aproximación de la línea de costa” - 1) Referencia:\n“Breast Cancer Wisconsin (Diagnostic) Data Set”\nfrom sklearn.linear_model import LogisticRegression from sklearn import datasets from sklearn.metrics import confusion_matrix from sklearn.model_selection import cross_val_predict from sklearn.model_selection import train_test_split import pandas as pd import numpy as np import matplotlib.pyplot as plt import seaborn as sns sns.set() # datos bcancer = datasets.load_breast_cancer() División de los datos\nSeparamos los datos en conjuntos de entrenamiento (training) y conjunto de prueba (testing).\nbcancer = datasets.load_breast_cancer() X = bcancer[\u0026#39;data\u0026#39;] y = bcancer[\u0026#39;target\u0026#39;] # Split data X_train, X_test, y_train, y_test = train_test_split(X, y, train_size=0.7, random_state=42, stratify=y) print(X_test.shape) ## (171, 30) Modelo\nAjustamos un …","date":1673748794,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1673748794,"objectID":"7c5a70631dac089fdb3375ad628d6d5a","permalink":"https://example.com/post/confusionmatrix/","publishdate":"2023-01-14T21:13:14-05:00","relpermalink":"/post/confusionmatrix/","section":"post","summary":"Confusion matrix is a very popular measure used while solving classification problems. It can be applied to binary classification as well as for multiclass classification problems.","tags":["Machine Learning","Statistics","Data Science"],"title":"Confusion Matrix","type":"post"},{"authors":null,"categories":["R"],"content":"Definición: Sean \\(T_1\\), \\(T_2\\), …, \\(T_n\\) v.a.i.i.d con distribución exponencial de parámetro \\(\\lambda\\), : \\(\\mathcal{E}xp(\\lambda)\\). : \\(\\mathcal{W}_0=0\\), \\(\\mathcal{W}_n=T_1, T_2, ..., T_n\\) para \\(n\\geq 1\\). Definimos el proceso Poisson de parámetro o intensidad \\(\\lambda\\) por\n$$\\begin{equation}\rN(t) = máx \\{n\\geq 1, \\ \\ \\mathcal{W}_n = T_1 + T_2 + ...+ T_n \\leq t\\}\r\\end{equation}$$\nLas variables aleatorias \\(T_n\\) representan los intervalos de tiempo entre eventos sucesivos, y \\(\\mathcal{W}_n = T_1, T_2, ..., T_n\\) representa el instante en el que ocurre el n-ésimo evento, y \\(N(t)\\) es el número de eventos que han ocurrido hasta el instante \\(t\\).\nProposición: La variable aleatoria \\(N(t)\\) tiene distribución Poisson con parámetro \\((\\lambda t)\\), es decir, para cualquier \\(t\u0026gt;0\\), y para \\(n=0, 1, ...\\)\n$$\\begin{equation}\rP(N(t) = n) = e^{-\\lambda t} \\frac{(\\lambda t)^n}{n!}\r\\end{equation}$$\nSu valor esperado, y varianza son\n$$E[N(t)] = \\lambda t$$\n$$Var(N(t)) = \\lambda t$$\n# Reading packages library(\u0026#34;ggplot2\u0026#34;) library(\u0026#34;dplyr\u0026#34;) library(\u0026#34;plotly\u0026#34;) library(\u0026#34;ggthemes\u0026#34;) library(\u0026#34;tidyr\u0026#34;) library(\u0026#34;stringr\u0026#34;) # Función para simular una trajectoria del proceso Poisson homogéneo sim.one.PoissonProcess \u0026lt;- function(run, tmax, lambda){ w \u0026lt;- c() w[1] \u0026lt;- 0 i \u0026lt;- 2 while(w[i-1] \u0026lt; tmax){ #i \u0026lt;- i + 1 Ti \u0026lt;- rexp(1, lambda) #print(Ti) if(w[i-1] + Ti \u0026lt; tmax){ w[i] \u0026lt;- w[i-1] + Ti }else{ break } i \u0026lt;- i + 1 } df \u0026lt;- data.frame(\u0026#39;runs\u0026#39; = rep(run, length(w)), \u0026#39;n\u0026#39; = 0:(length(w)-1), \u0026#39;t\u0026#39; = w) return(df) } # Función para simular n trajectorias del proceso Poisson homogéneo sim.PoissonProcess \u0026lt;- function(n.runs, tmax, lambda){ for(i in 1:n.runs){ if(i == 1){ df_1 \u0026lt;- sim.one.PoissonProcess(run=i, tmax, lambda) }else{ df_i \u0026lt;- sim.one.PoissonProcess(run=i, tmax, lambda) df_1 \u0026lt;- rbind(df_1, df_i) } } return(df_1) } Ejemplo 1: Una trayectoria del proceso Poisson # Example : n.runs \u0026lt;- 1 # número de trayectorias del proceso tmax \u0026lt;- 500 # t máximo lambda \u0026lt;- 0.2 # parámetro # Simulación sim.PP \u0026lt;- sim.PoissonProcess(n.runs, tmax, lambda) # Media y varianza moments_pp \u0026lt;- data.frame(\u0026#39;t\u0026#39;=c(0:tmax),\u0026#39;lambda\u0026#39;=lambda) %\u0026gt;% mutate(\u0026#39;mean\u0026#39; = t*lambda, \u0026#39;sd_inf\u0026#39; = mean - 2*sqrt(t*lambda), \u0026#39;sd_sup\u0026#39; = mean + 2*sqrt(t*lambda)) head(sim.PP) ## runs n t ## 1 1 0 0.000000 ## 2 1 1 6.509327 ## 3 1 2 8.934217 ## 4 1 3 13.989072 ## 5 1 4 14.494091 ## 6 1 5 14.790950 # Gráfico del proceso Poisson options(repr.plot.width=16, repr.plot.height=8) p1 \u0026lt;- ggplot(sim.PP, mapping=aes(x=t, y=n, color = runs)) + geom_step(sim.PP, mapping=aes(x=t, y=n, group = runs), alpha = 0.25, col=\u0026#39;black\u0026#39;) + geom_step(moments_pp, mapping=aes(x=t,y=mean),col=\u0026#39;red\u0026#39;,size=0.7, alpha=0.5) + geom_step(moments_pp, mapping=aes(x=t,y=sd_sup),col=\u0026#39;blue\u0026#39;,size=0.7,linetype = \u0026#34;dashed\u0026#34;) + geom_step(moments_pp, mapping=aes(x=t,y=sd_inf),col=\u0026#39;blue\u0026#39;,size=0.7,linetype = \u0026#34;dashed\u0026#34;) + labs( title = paste(n.runs, \u0026#34;Trajectorias del proceso Poisson con lambda \u0026#34;, lambda)) + theme(legend.position = \u0026#34;none\u0026#34;) + scale_colour_grey(start = 0.2,end = 0.8) + coord_cartesian(xlim = c(0, tmax)) p1 Ejemplo 2: Ocho mil trayectorias del proceso Poisson # Example : n.runs \u0026lt;- 8000 # número de trayectorias del proceso tmax \u0026lt;- 500 # t máximo lambda \u0026lt;- 0.2 # parámetro # Simulación sim.PP \u0026lt;- sim.PoissonProcess(n.runs, tmax, lambda) # Media y varianza moments_pp \u0026lt;- data.frame(\u0026#39;t\u0026#39;=c(0:tmax),\u0026#39;lambda\u0026#39;=lambda) %\u0026gt;% mutate(\u0026#39;mean\u0026#39; = t*lambda, \u0026#39;sd_inf\u0026#39; = mean - 2*sqrt(t*lambda), \u0026#39;sd_sup\u0026#39; = mean + 2*sqrt(t*lambda)) # Gráfico del proceso Poisson options(repr.plot.width=16, repr.plot.height=8) p1 \u0026lt;- ggplot(sim.PP, mapping=aes(x=t, y=n, color = runs)) + geom_step(sim.PP, mapping=aes(x=t, y=n, group = runs), alpha = 0.25, col=\u0026#39;black\u0026#39;) + geom_step(moments_pp, mapping=aes(x=t,y=mean),col=\u0026#39;red\u0026#39;,size=0.7, alpha=0.5) + geom_step(moments_pp, mapping=aes(x=t,y=sd_sup),col=\u0026#39;blue\u0026#39;,size=0.7,linetype = \u0026#34;dashed\u0026#34;) + geom_step(moments_pp, mapping=aes(x=t,y=sd_inf),col=\u0026#39;blue\u0026#39;,size=0.7,linetype = \u0026#34;dashed\u0026#34;) + labs( title = paste(n.runs, \u0026#34;Trajectorias del proceso Poisson con lambda \u0026#34;, lambda)) + theme(legend.position = \u0026#34;none\u0026#34;) + scale_colour_grey(start = 0.2,end = 0.8) + coord_cartesian(xlim = c(0, tmax)) p1 Valor esperado y varianza de \\(N(t)\\):\n$$E[N(t)] = \\lambda t $$ $$Var(N(t)) = \\lambda t $$\nPara este ejemplo con \\(t=50\\) y \\(\\lambda = 0.2\\):\n$$E[N(t)] = 0.2(50) = 10$$ $$Var(N(t)) = 0.2(50) = 10$$\n# Verificación mediante simulación para t=50 sim.PP %\u0026gt;% filter(t\u0026lt;=50) %\u0026gt;% group_by(runs) %\u0026gt;% summarise(Nt=max(n)) %\u0026gt;% summarise(mean=mean(Nt), var=var(Nt)) ## # A tibble: 1 × 2 ## mean var ## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; ## 1 10.1 10.0 Covarianza Para un proceso Poisson con parámetro lambda \\(\\lambda\\), y \\(s\u0026lt;t\\) la covarianza entre \\(N(s)\\) y \\(N(t)\\) es\n$$\\begin{equation}\rCov(N(s), N(t)) = \\lambda s\r\\end{equation}$$\nEjemplo: Obtener:\n1.- \\(Cov(N(5), N(6))\\)\n2.- \\(Cov(N(10), N(100))\\)\nSolución teórica: 1.- \\(Cov(N(5), N(6))= \\lambda s = (0.2)(5)= 1\\)\n2.- \\(Cov(N(100), N(40))= \\lambda s = (0.2)(40)= 8\\)\nSimulación: # Solución $Cov(N(5), N(6))$ # Obtenemos N(5) N_5 \u0026lt;- sim.PP …","date":1607220974,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607220974,"objectID":"586a94dbf4ecd6fd075c032b070107d1","permalink":"https://example.com/post/poissonprocess/","publishdate":"2020-12-05T21:16:14-05:00","relpermalink":"/post/poissonprocess/","section":"post","summary":"A Poisson Process is a stochastic model for discrete events where the average time between events is known, but the exact timing of events is random. The arrival of an event is independent of the event before, this means that waiting time between events is memoryless.","tags":["Stochastic Processes","Statistics","Simulation"],"title":"Poisson Process","type":"post"},{"authors":null,"categories":["R"],"content":"Definición: Sea \\(\\{B(t), t \\geq 0\\}\\) un movimiento Browniano estándar. El procesos estocástico \\(\\{X(t)= \\mu t + \\sigma B(t), t \\geq 0\\}\\) recibe el nombre de movimiento Browniano con coeficiente de deriva (drift) \\(\\mu\\), y volatilidad (o difusión) \\(\\sigma\\).\nProposición La distribucuión de \\(X(t)\\) es normal con media \\(\\mu t\\), y varianza \\(\\sigma^2 t\\). Y la covarianza entre \\(X(s)\\) y \\(X(t)\\) es\n$$Cov(X(s), X(t)) = \\sigma^2 min(s, t)$$\n# Función para generar trajectorias del movimiento Browniano con coeficiente de deriva y volatilidad simMB.drift \u0026lt;- function(mu, sigma, t, nSteps, nReps){ dt \u0026lt;- t/ nSteps # loop simMat \u0026lt;- matrix(nrow=nReps, ncol=(nSteps+1)) simMat[ ,1] \u0026lt;- 0 for(i in 1:nReps){ for(j in 2:(nSteps + 1)){ simMat[i,j] \u0026lt;- simMat[i,j-1] + mu*dt + sigma*sqrt(dt)*rnorm(1,0,1) } } names \u0026lt;- c(\u0026#39;Rep\u0026#39;, sapply(0:nSteps, function(i) paste(\u0026#39;S\u0026#39;,i,sep=\u0026#39;\u0026#39;))) df \u0026lt;- data.frame(\u0026#39;Rep\u0026#39;=1:nReps, simMat) colnames(df) \u0026lt;- names return(df) } Ejemplo 1: Una trayectoria # Ejemplo t \u0026lt;- 1 mu \u0026lt;- 0.3 sigma \u0026lt;- 0.06 nSteps \u0026lt;- 1000 # número de pasos nReps \u0026lt;- 1 # número de trayectorias bm1 \u0026lt;- simMB.drift(mu, sigma, t, nSteps, nReps) #print(bm1) # data df \u0026lt;- bm1 %\u0026gt;% pivot_longer(!Rep, names_to=\u0026#39;Step\u0026#39;, values_to=\u0026#39;value\u0026#39;) %\u0026gt;% mutate(\u0026#39;t\u0026#39; = as.numeric(substring(Step,2,10))*t/nSteps, Rep = as.character(Rep)) # Valores teóricos moments \u0026lt;- data.frame(\u0026#39;t1\u0026#39;=seq(from=0, to=1, length=nSteps+1)*t) %\u0026gt;% mutate(\u0026#39;mean\u0026#39; = mu*t1, \u0026#39;sd_inf\u0026#39; = mean - 2*sqrt(sigma^2*t1), \u0026#39;sd_sup\u0026#39; = mean + 2*sqrt(sigma^2*t1)) head(df) ## # A tibble: 6 × 4 ## Rep Step value t ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; ## 1 1 S0 0 0 ## 2 1 S1 0.00119 0.001 ## 3 1 S2 0.00129 0.002 ## 4 1 S3 0.00146 0.003 ## 5 1 S4 0.00194 0.004 ## 6 1 S5 0.00561 0.005 # Gráfico options(repr.plot.width=16, repr.plot.height=8) p1 \u0026lt;- ggplot(df, aes(x=t, y=value, color=Rep)) + geom_line() + geom_line(moments, mapping=aes(x=t1,y=mean),col=\u0026#39;red\u0026#39;,size=0.7, alpha=0.5) + geom_line(moments, mapping=aes(x=t1,y=sd_sup),col=\u0026#39;blue\u0026#39;,size=0.7,linetype = \u0026#34;dashed\u0026#34;) + geom_line(moments, mapping=aes(x=t1,y=sd_inf),col=\u0026#39;blue\u0026#39;,size=0.7,linetype = \u0026#34;dashed\u0026#34;) + labs( title = paste(nReps, \u0026#34;Trajectorias del MB\u0026#34;)) + theme(legend.position = \u0026#34;none\u0026#34;) + scale_colour_grey(start = 0.2,end = 0.8) #coord_cartesian(xlim = c(0, tmax)) p1 Ejemplo 2: Diez mil trayectorias # valores t \u0026lt;- 1 mu \u0026lt;- 0.3 sigma \u0026lt;- 0.06 nSteps \u0026lt;- 1000 # número de pasos nReps \u0026lt;- 10000 # número de trayectorias bm1 \u0026lt;- simMB.drift(mu, sigma, t, nSteps, nReps) #data df \u0026lt;- bm1 %\u0026gt;% pivot_longer(!Rep, names_to=\u0026#39;Step\u0026#39;, values_to=\u0026#39;value\u0026#39;) %\u0026gt;% mutate(t = as.numeric(substring(Step,2,10))*t/nSteps, Rep = as.character(Rep)) # Valores teóricos moments \u0026lt;- data.frame(\u0026#39;t1\u0026#39;=seq(from=0, to=1, length=nSteps+1)*t) %\u0026gt;% mutate(\u0026#39;mean\u0026#39; = mu*t1, \u0026#39;sd_inf\u0026#39; = mean - 2*sqrt(sigma^2*t1), \u0026#39;sd_sup\u0026#39; = mean + 2*sqrt(sigma^2*t1)) # Gráfico del Movimiento Browniano con coeficiente de deriva y volatilidad options(repr.plot.width=16, repr.plot.height=8) p1 \u0026lt;- ggplot(df, mapping=aes(x=t, y=value, color=Rep)) + geom_line() + geom_line(moments, mapping=aes(x=t1,y=mean),col=\u0026#39;red\u0026#39;,size=0.7, alpha=0.5) + geom_line(moments, mapping=aes(x=t1,y=sd_sup),col=\u0026#39;blue\u0026#39;,size=0.7,linetype = \u0026#34;dashed\u0026#34;) + geom_line(moments, mapping=aes(x=t1,y=sd_inf),col=\u0026#39;blue\u0026#39;,size=0.7,linetype = \u0026#34;dashed\u0026#34;) + labs( title = paste(nReps, \u0026#34;Trayectorias del MB\u0026#34;)) + theme(legend.position = \u0026#34;none\u0026#34;) + scale_colour_grey(start = 0.2,end = 0.8) #coord_cartesian(xlim = c(0, tmax)) p1 Ejemplo:\nPara \\(\\mu=0.3\\), y \\(\\sigma = 0.06\\) obtener\n\\(E[X(10)]\\) = ? \\(Var(X(10))\\) = ? \\(Cov(X(10, 20))\\) = ? Solución teórica:\n\\(E[X(10)] = \\mu t = 0.3*10 = 3\\) \\(Var(X(10)) = \\sigma^2 * t = 0.036*10 = 0.036\\) \\(Cov(X(10), x(20)) = \\sigma^2 min(s, t) = 0.036*10 = 0.036\\) Simulación:\nDado que el proceso está escalado en el intervalo \\([0, 1]\\), las estimaciones deben multiplicarse por el número de pasos generados, es decir por \\(nSteps\\).\n# Valor esperado E[X(10)] mean(bm1[,10+1])*nSteps ## [1] 2.713745 # Varianza var(bm1[,10+1])*nSteps ## [1] 0.03206319 # Covarianza cov(bm1[,10+1], bm1[,20+1])*nSteps ## [1] 0.03236365 Movimiento Browniano con coeficiente de deriva y volatilidad en dos dimensiones # Movimiento Browniano con coeficiente de deriva y valatilidad en dos dimensiones plot.MB2d_drift \u0026lt;- function(base, n.steps){ df \u0026lt;- base df_2d \u0026lt;- df %\u0026gt;% gather(key=\u0026#39;t\u0026#39;,value=\u0026#39;valor\u0026#39;,-Rep) %\u0026gt;% filter(Rep == 1 | Rep== 2) %\u0026gt;% spread(Rep, valor) %\u0026gt;% rename(Rep1 = \u0026#39;1\u0026#39;, Rep2=\u0026#39;2\u0026#39;)%\u0026gt;% mutate(t = as.numeric(substring(t,2,10))) %\u0026gt;% arrange(t) %\u0026gt;% filter(t \u0026lt;= n.steps) b2 \u0026lt;- ggplot(df_2d,aes(x=Rep1,y=Rep2))+ geom_point(color=\u0026#34;blue\u0026#34;) + geom_point(df_2d%\u0026gt;%filter(t == 0),mapping=aes(x=Rep1,y=Rep2), size=4, color=\u0026#34;green\u0026#34;) + geom_point(df_2d%\u0026gt;%filter(t == max(t)),mapping=aes(x=Rep1,y=Rep2), size=3, color=\u0026#34;red\u0026#34;) + geom_path() + theme(axis.title.x = element_blank(), axis.title.y = element_blank(), axis.text.x=element_blank(), axis.text.y=element_blank(), axis.ticks.x=element_blank(), axis.ticks.y=element_blank() ) return(b2) } Ejemplo 1: Diez mil pasos # Ejemplo 1: t \u0026lt;- 1 mu \u0026lt;- 0.1 sigma \u0026lt;- …","date":1607134394,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607134394,"objectID":"542fcd0e78ba189b738ad0881ba5b0c3","permalink":"https://example.com/post/brownianmotiondriftvolatility/","publishdate":"2020-12-04T21:13:14-05:00","relpermalink":"/post/brownianmotiondriftvolatility/","section":"post","summary":"A Brownian motion with drift and volatility is a process with directional tendency, we can think of an additive component resembling a slope growing over time. In mathematical terms it means we have some constant, let's say  multiplying the time variable.","tags":["Stochastic Processes","Statistics","Simulation"],"title":"Brownian motion with drift and volatility","type":"post"},{"authors":null,"categories":["R"],"content":"Definición: Un procesos estocástico \\(\\{X(t)= B(t) - \\frac{t}{T} B(T) , 0 \\leq t \\leq T \\}\\), es un puente Browniano si satisface las siguientes propiedades:\n1.- \\(X(0)=X(T)=0\\)\n2.- \\(X(t)\\) se distribuye como una normal con media cero y varianza \\(t(1-t/T)\\)\n$$E[X(t)] = 0$$, y $$Var(X(t)) = t(1-t/T)$$\n3.- \\(Cov(X(s), X(t)) = min(s, t) - \\frac{st}{T}\\)\nSimulación # Función para generar trajectorias del Puente Browniano (PB) simPB \u0026lt;- function(t=1, nSteps, nReps){ dt \u0026lt;- t #/ nSteps # Simulación de un Movimiento Browniano BM \u0026lt;- matrix(nrow=nReps, ncol=(nSteps+1)) BM[ ,1] \u0026lt;- 0 for(i in 1:nReps){ for(j in 2:(nSteps + 1)){ BM[i,j] \u0026lt;- BM[i,j-1] + sqrt(dt)*rnorm(1,0,1) } } # Simulación del puente Browniano BB \u0026lt;- matrix(nrow=nReps, ncol=(nSteps+1)) BB[ ,1] \u0026lt;- 0 for(i in 1:nReps){ for(j in 2:(nSteps + 1)){ BB[i,j] \u0026lt;- BM[i,j]-(j/nSteps)*BM[i,nSteps+1] } } # Data frame names \u0026lt;- c(\u0026#39;Rep\u0026#39;, sapply(0:nSteps, function(i) paste(\u0026#39;S\u0026#39;,i,sep=\u0026#39;\u0026#39;))) df \u0026lt;- data.frame(\u0026#39;Rep\u0026#39;=1:nReps, BB) colnames(df) \u0026lt;- names return(df) } Ejemplo 1: Una trayectoria del Puente Browniano # Ejemplo 1 t \u0026lt;- 1 # incrementos nSteps \u0026lt;- 1000 # número de pasos nReps \u0026lt;- 1 # número de trayectorias pb1 \u0026lt;- simPB(t, nSteps, nReps) # data df \u0026lt;- pb1 %\u0026gt;% pivot_longer(!Rep, names_to=\u0026#39;Step\u0026#39;, values_to=\u0026#39;value\u0026#39;) %\u0026gt;% mutate(t = as.numeric(substring(Step,2,10))*t, Rep = as.character(Rep)) head(df) ## # A tibble: 6 × 4 ## Rep Step value t ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; ## 1 1 S0 0 0 ## 2 1 S1 0.411 1 ## 3 1 S2 0.468 2 ## 4 1 S3 0.878 3 ## 5 1 S4 0.895 4 ## 6 1 S5 2.04 5 # Valores teóricos moments \u0026lt;- data.frame(\u0026#39;t\u0026#39;=seq(from=0, to=nSteps, length=nSteps+1)*t) %\u0026gt;% mutate(\u0026#39;mean\u0026#39; = 0, \u0026#39;sd_inf\u0026#39; = mean - 2*sqrt(t*(1-t/nSteps)), \u0026#39;sd_sup\u0026#39; = mean + 2*sqrt(t*(1-t/nSteps))) # Gráfico options(repr.plot.width=16, repr.plot.height=8) p1 \u0026lt;- ggplot(df, mapping=aes(x=t, y=value, color=Rep)) + geom_line() + geom_step(moments, mapping=aes(x=t,y=mean),col=\u0026#39;red\u0026#39;, linewidth=0.7, alpha=0.5) + geom_step(moments, mapping=aes(x=t,y=sd_sup),col=\u0026#39;blue\u0026#39;, linewidth=0.7,linetype = \u0026#34;dashed\u0026#34;) + geom_step(moments, mapping=aes(x=t,y=sd_inf),col=\u0026#39;blue\u0026#39;, linewidth=0.7,linetype = \u0026#34;dashed\u0026#34;) + labs( title = paste(nReps, \u0026#34;Trajectorias del BB\u0026#34;)) + theme(legend.position = \u0026#34;none\u0026#34;) + scale_colour_grey(start = 0.2,end = 0.8) #coord_cartesian(xlim = c(0, tmax)) p1 Ejemplo 2: Mil trayectorias del puente Browniano # valores t \u0026lt;- 1 # incremento nSteps \u0026lt;- 1000 # número de pasos nReps \u0026lt;- 1000 # número de trayectorias pb1 \u0026lt;- simPB(t, nSteps, nReps) # data df \u0026lt;- pb1 %\u0026gt;% pivot_longer(!Rep, names_to=\u0026#39;Step\u0026#39;, values_to=\u0026#39;value\u0026#39;) %\u0026gt;% mutate(t = as.numeric(substring(Step,2,10))*t, Rep = as.character(Rep)) head(df) ## # A tibble: 6 × 4 ## Rep Step value t ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; ## 1 1 S0 0 0 ## 2 1 S1 0.139 1 ## 3 1 S2 -0.224 2 ## 4 1 S3 -0.579 3 ## 5 1 S4 -0.114 4 ## 6 1 S5 1.55 5 # Valores teóricas moments \u0026lt;- data.frame(\u0026#39;t\u0026#39;=seq(from=0, to=nSteps, length=nSteps+1)*t) %\u0026gt;% mutate(\u0026#39;mean\u0026#39; = 0, \u0026#39;sd_inf\u0026#39; = mean - 2*sqrt(t*(1-t/nSteps)), \u0026#39;sd_sup\u0026#39; = mean + 2*sqrt(t*(1-t/nSteps))) # Gráfico del Puente Browniano options(repr.plot.width=16, repr.plot.height=8) p1 \u0026lt;- ggplot(df, mapping=aes(x=t, y=value, color=Rep)) + geom_line() + geom_step(moments, mapping=aes(x=t,y=mean),col=\u0026#39;red\u0026#39;, linewidth=0.7, alpha=0.5) + geom_step(moments, mapping=aes(x=t,y=sd_sup),col=\u0026#39;blue\u0026#39;, linewidth=0.7,linetype = \u0026#34;dashed\u0026#34;) + geom_step(moments, mapping=aes(x=t,y=sd_inf),col=\u0026#39;blue\u0026#39;, linewidth=0.7,linetype = \u0026#34;dashed\u0026#34;) + labs( title = paste(nReps, \u0026#34;Trajectorias del MB\u0026#34;)) + theme(legend.position = \u0026#34;none\u0026#34;) + scale_colour_grey(start = 0.2,end = 0.8) #coord_cartesian(xlim = c(0, tmax)) p1 Puente Browniano en dos dimensiones # Puente Browniano en dos dimensiones plot.PB2d \u0026lt;- function(base, n.steps){ df \u0026lt;- base df_2d \u0026lt;- df %\u0026gt;% gather(key=\u0026#39;t\u0026#39;,value=\u0026#39;valor\u0026#39;,-Rep) %\u0026gt;% filter(Rep == 1 | Rep== 2) %\u0026gt;% spread(Rep, valor) %\u0026gt;% rename(Rep1 = \u0026#39;1\u0026#39;, Rep2=\u0026#39;2\u0026#39;)%\u0026gt;% mutate(t = as.numeric(substring(t,2,10))) %\u0026gt;% arrange(t) %\u0026gt;% filter(t \u0026lt;= n.steps) b2 \u0026lt;- ggplot(df_2d,aes(x=Rep1,y=Rep2))+ geom_point(color=\u0026#34;blue\u0026#34;) + geom_point(df_2d%\u0026gt;%filter(t == 0),mapping=aes(x=Rep1,y=Rep2), size=4, color=\u0026#34;green\u0026#34;) + geom_point(df_2d%\u0026gt;%filter(t == max(t)),mapping=aes(x=Rep1,y=Rep2), size=3, color=\u0026#34;red\u0026#34;) + geom_path() + theme(axis.title.x = element_blank(), axis.title.y = element_blank(), axis.text.x=element_blank(), axis.text.y=element_blank(), axis.ticks.x=element_blank(), axis.ticks.y=element_blank() ) return(b2) } Ejemplo 1: Diez mil pasos # Ejemplo 1: t \u0026lt;- 1 nSteps \u0026lt;- 10000 nReps \u0026lt;- 1000 # Gráfico options(repr.plot.width=14, repr.plot.height=10) df \u0026lt;- simPB(t, nSteps, nReps) p3 \u0026lt;- plot.PB2d(df, nSteps) p3 ","date":1607047994,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607047994,"objectID":"37c84e465609f3908368d560dbbf10c0","permalink":"https://example.com/post/brownianbridge/","publishdate":"2020-12-03T21:13:14-05:00","relpermalink":"/post/brownianbridge/","section":"post","summary":"A Brownian bridge can be defined as standard Brownian motion conditioned on hitting zero at a fixed future time T, or as any continuous process with the same distribution as this. Rather than conditioning, a slightly easier approach is to subtract a linear term from the Brownian motion, chosen such that the resulting process hits zero at the time T.","tags":["Stochastic Processes","Statistics","Simulation"],"title":"Brownian Bridge","type":"post"},{"authors":null,"categories":["R"],"content":"Definición: Un proceso estocástico \\(\\{B(t), t\\geq 0\\}\\) es un movimiento Browniano si cumple las siguientes propiedades:\n1.- \\(B(0) = 0\\)\n2.- \\(\\{B(t), t\\geq 0\\}\\) tiene incrementos independientes y estacionarios.\n3.- Para \\(t\u0026gt;0\\), B(t) tiene distribución normal con media cero y varianza \\(t\\).\nSimulación: Sea\n$$0 = t_0 \u0026lt; t_1 \u0026lt; t_2 \u0026lt; , ..., \u0026lt; t_{n-1} \u0026lt; t_n = T$$ \\\nConsideremos una partición sobre \\([0, T]\\) dada por \\(\\Delta t = T/n\\), tal que\n$$0 = t_0 \u0026lt; t_1=\\Delta t \u0026lt; t_2 = 2\\Delta t \u0026lt; , ..., \u0026lt; t_{n-1} = (n-1)\\Delta t\u0026lt; t_n = n \\Delta t = T$$ \\\nentonces para simular trajectorias del movimiento Browniano consideremos los incrementos\n$$B(t_1) - B(t_0) \\sim N(0, t_1 - t_0) = N(0, \\Delta t - 0) = \\sqrt{\\Delta t} N(0, 1)$$ $$ B(t_2) - B(t_1) \\sim N(0, t_2 - t_1) = N(0, 2\\Delta t-\\Delta t) = \\sqrt{\\Delta t} N(0, 1)$$ $$ \\vdots $$ $$ B(t_n) - B(t_{n-1}) \\sim N(0, t_n - t_{n-1}) = N(0, n\\Delta t-(n-1)\\Delta t) = \\sqrt{\\Delta t} N(0, 1)$$ \\\nSumando los incrementos se tiene que\n$$ B(t_n) - B(t_0) \\sim \\sum_{i=1}^{n} \\sqrt{\\Delta t} N(0, 1)$$\ndado que \\(B(t_0) = 0\\) entonces\n$$ B(t_n) \\sim \\sqrt{\\Delta t} \\sum_{i=1}^{n} N(0, 1)$$\ny dado que \\(\\sqrt{\\Delta t} = T/n\\), finalmente tenemos que\n$$ B(t_n) \\sim \\sqrt{\\frac{T}{n}} \\sum_{i=1}^{n} N(0, 1)$$\n# Función para simular un movimiento Browniano simMB \u0026lt;- function(t, nSteps, nReps){ dt \u0026lt;- t/ nSteps # simMat \u0026lt;- matrix(nrow=nReps, ncol=(nSteps+1)) simMat[ ,1] \u0026lt;- 0 for(i in 1:nReps){ for(j in 2:(nSteps + 1)){ simMat[i,j] \u0026lt;- simMat[i,j-1] + sqrt(dt)*rnorm(1,0,1) } } names \u0026lt;- c(\u0026#39;Rep\u0026#39;, sapply(0:nSteps, function(i) paste(\u0026#39;S\u0026#39;,i,sep=\u0026#39;\u0026#39;))) df \u0026lt;- data.frame(\u0026#39;Rep\u0026#39;=1:nReps, simMat) colnames(df) \u0026lt;- names return(df) } Ejemplo 1: Una trayectoria del Movimiento Browniano # valores t \u0026lt;- 1000 nSteps \u0026lt;- 1000 # número de pasos nReps \u0026lt;- 1 # número de trajectorias bm1 \u0026lt;- simMB(t, nSteps, nReps) # data df \u0026lt;- bm1 %\u0026gt;% pivot_longer(!Rep, names_to=\u0026#39;Step\u0026#39;, values_to=\u0026#39;value\u0026#39;) %\u0026gt;% mutate(t = as.numeric(substring(Step,2,10))*t/nSteps, Rep = as.character(Rep)) head(df) ## # A tibble: 6 × 4 ## Rep Step value t ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; ## 1 1 S0 0 0 ## 2 1 S1 -0.391 1 ## 3 1 S2 -0.735 2 ## 4 1 S3 0.977 3 ## 5 1 S4 -0.826 4 ## 6 1 S5 -0.813 5 # valores teóricos moments \u0026lt;- data.frame(\u0026#39;t\u0026#39;=seq(from=0, to=1, length=nSteps+1)*t) %\u0026gt;% mutate(\u0026#39;mean\u0026#39; = 0, \u0026#39;sd_inf\u0026#39; = mean - 2*sqrt(t), \u0026#39;sd_sup\u0026#39; = mean + 2*sqrt(t)) # Gráfico options(repr.plot.width=16, repr.plot.height=8) p1 \u0026lt;- ggplot(df, mapping=aes(x=t, y=value, color=Rep)) + geom_line() + geom_step(moments, mapping=aes(x=t,y=mean),col=\u0026#39;red\u0026#39;,size=0.7, alpha=0.5) + geom_step(moments, mapping=aes(x=t,y=sd_sup),col=\u0026#39;blue\u0026#39;,size=0.7,linetype = \u0026#34;dashed\u0026#34;) + geom_step(moments, mapping=aes(x=t,y=sd_inf),col=\u0026#39;blue\u0026#39;,size=0.7,linetype = \u0026#34;dashed\u0026#34;) + labs( title = paste(nReps, \u0026#34;Trajectoria(s) del MB\u0026#34;)) + theme(legend.position = \u0026#34;none\u0026#34;) + scale_colour_grey(start = 0.2,end = 0.8) #coord_cartesian(xlim = c(0, tmax)) p1 Ejemplo 2: Mil trayectorias del movimiento Browniano # valores t \u0026lt;- 1000 nSteps \u0026lt;- 1000 # número de pasos nReps \u0026lt;- 1000 # número de trajectorias bm1 \u0026lt;- simMB(t, nSteps, nReps) # data df \u0026lt;- bm1 %\u0026gt;% pivot_longer(!Rep, names_to=\u0026#39;Step\u0026#39;, values_to=\u0026#39;value\u0026#39;) %\u0026gt;% mutate(t = as.numeric(substring(Step,2,10))*t/nSteps, Rep = as.character(Rep)) # valores teóricos moments \u0026lt;- data.frame(\u0026#39;t\u0026#39;=seq(from=0, to=1, length=nSteps+1)*t) %\u0026gt;% mutate(\u0026#39;mean\u0026#39; = 0, \u0026#39;sd_inf\u0026#39; = mean - 2*sqrt(t), \u0026#39;sd_sup\u0026#39; = mean + 2*sqrt(t)) # Gráfico options(repr.plot.width=16, repr.plot.height=8) p1 \u0026lt;- ggplot(df, mapping=aes(x=t, y=value, color=Rep)) + geom_line() + geom_step(moments, mapping=aes(x=t,y=mean),col=\u0026#39;red\u0026#39;,size=0.7, alpha=0.5) + geom_step(moments, mapping=aes(x=t,y=sd_sup),col=\u0026#39;blue\u0026#39;,size=0.7,linetype = \u0026#34;dashed\u0026#34;) + geom_step(moments, mapping=aes(x=t,y=sd_inf),col=\u0026#39;blue\u0026#39;,size=0.7,linetype = \u0026#34;dashed\u0026#34;) + labs( title = paste(nReps, \u0026#34;Trajectoria(s) del MB\u0026#34;)) + theme(legend.position = \u0026#34;none\u0026#34;) + scale_colour_grey(start = 0.2,end = 0.8) #coord_cartesian(xlim = c(0, tmax)) p1 Movimiento Browniano en dos dimensiones # Función del movimiento Browniano en dos dimensiones plot.BM2d \u0026lt;- function(base, n.steps){ df \u0026lt;- base df_2d \u0026lt;- df %\u0026gt;% gather(key=\u0026#39;t\u0026#39;,value=\u0026#39;valor\u0026#39;,-Rep) %\u0026gt;% filter(Rep == 1 | Rep== 2) %\u0026gt;% spread(Rep, valor) %\u0026gt;% rename(Rep1 = \u0026#39;1\u0026#39;, Rep2=\u0026#39;2\u0026#39;)%\u0026gt;% mutate(t = as.numeric(substring(t,2,10))) %\u0026gt;% arrange(t) %\u0026gt;% filter(t \u0026lt;= n.steps) b2 \u0026lt;- ggplot(df_2d,aes(x=Rep1,y=Rep2))+ geom_point(color=\u0026#34;blue\u0026#34;) + geom_point(df_2d%\u0026gt;%filter(t == 1),mapping=aes(x=Rep1,y=Rep2),color=\u0026#34;green\u0026#34;) + geom_point(df_2d%\u0026gt;%filter(t == max(t)),mapping=aes(x=Rep1,y=Rep2),color=\u0026#34;red\u0026#34;) + geom_path() + theme(axis.title.x = element_blank(), axis.title.y = element_blank(), axis.text.x=element_blank(), axis.text.y=element_blank(), axis.ticks.x=element_blank(), axis.ticks.y=element_blank()) return(b2) } Ejemplo 1 # Ejemplo 1: t \u0026lt;- 1 n.steps \u0026lt;- 10000 # número de pasos n.sim \u0026lt;- 1000 # número de trayectorias # Gráfico df \u0026lt;- simMB(t, n.steps, n.sim) p3 \u0026lt;- plot.BM2d(df, n.steps) p3 ","date":1606961594,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1606961594,"objectID":"bc41d641a98525e20680785b3ffe44e2","permalink":"https://example.com/post/brownianmotion/","publishdate":"2020-12-02T21:13:14-05:00","relpermalink":"/post/brownianmotion/","section":"post","summary":"Brownian motion is one of the most important random process. It has been used in engineering, finance, and physical sciences. It is a Gaussian random process and it has been used to model motion of particles suspended in a fluid, percentage changes in the stock prices, etc.","tags":["Stochastic Processes","Statistics","Simulation"],"title":"Brownian Motion","type":"post"},{"authors":null,"categories":["Python"],"content":"import pandas as pd import numpy as np from numpy.random import uniform import matplotlib.pyplot as plt import seaborn as sns sns.set() Origen Sea $$ \\overrightarrow{R}_n = \\overrightarrow{r}_1 + \\overrightarrow{r}_2 + … + \\overrightarrow{r}_n $$\ndonde\n\\begin{equation}\r\\overrightarrow{R}_x = l \\sum_{i=1}^{n} cos(\\theta_i)\\\\\r\\overrightarrow{R}_y = l \\sum_{i=1}^{n} sen(\\theta_i) \\end{equation}\n$$|R_n| = \\sqrt{\\overrightarrow{R}_x + \\overrightarrow{R}_y} $$\n# Pearson Random Walk function def PearsonRandomWalk(nsteps, l=1): rx = [0]*(nsteps+1) ry = [0]*(nsteps+1) for i in range(1, nsteps+1): theta = uniform(low=0, high=2*np.pi, size=1)[0] rx[i] = l*np.cos(theta) ry[i] = l*np.sin(theta) rx = np.array(rx) ry = np.array(ry) Rx = rx.cumsum() Ry = ry.cumsum() R2 = Rx**2 + Ry**2 R = np.sqrt(R2) return rx, ry, Rx, Ry, R2, R nsteps = 5000 npaths = 5000 # multiple paths rxs, rys, Rxs, Rys, R2s, Rs = [], [], [], [], [], [] # loop for i in range(npaths): rx, ry, Rx, Ry, R2, R = PearsonRandomWalk(nsteps) rxs.append(rx) rys.append(ry) Rxs.append(Rx) Rys.append(Ry) R2s.append(R2) Rs.append(R) Caminata Aleatoria de Pearson x = np.array([*range(nsteps+1)]) # media y varianza de la distribución Rayleigh mean = np.sqrt(x/2)*np.sqrt(np.pi/2) variance = ((x/2))*((4-np.pi)/2) # gráfico plt.figure(figsize=(18,8)) for r in Rs: plt.plot(x, r, \u0026#39;-\u0026#39;, color=\u0026#39;grey\u0026#39;, alpha=0.4) plt.plot(x, mean, \u0026#39;-\u0026#39;, color=\u0026#39;red\u0026#39;, alpha=0.4) plt.plot(x, mean + 3*np.sqrt(variance), \u0026#39;--\u0026#39;, color=\u0026#39;blue\u0026#39;, alpha=0.4) plt.plot(x, [0]*len(x), \u0026#39;--\u0026#39;, color=\u0026#39;blue\u0026#39;, alpha=0.4) plt.title(\u0026#39;Pearson Random Walk\u0026#39;) plt.show() Veamos el promedio de las trayetorias con respecto a \\(t\\).\nx = np.array([*range(nsteps+1)]) plt.figure(figsize=(18,8)) plt.plot(np.array(Rs).mean(axis=0) , \u0026#39;.\u0026#39;, color=\u0026#39;grey\u0026#39;, alpha=0.9, label=\u0026#39;Promedio\u0026#39;) plt.plot(x, np.sqrt(x/2)*np.sqrt(np.pi/2), \u0026#39;-\u0026#39;, color=\u0026#39;blue\u0026#39;, alpha=0.4, label=\u0026#39;Valor esperado teórico\u0026#39;) plt.title(\u0026#39;Pearson Random Walk\u0026#39;) plt.legend() plt.show() Distribución de \\(\\overrightarrow{R}_n\\) Rn = [r[nsteps] for r in Rs] plt.figure(figsize=(16,7)) sns.kdeplot(Rn, color=\u0026#39;red\u0026#39;) plt.hist(Rn, bins=40, density=True) plt.title(\u0026#39;Distribución de $R_n$\u0026#39;) plt.show() Distribución de \\(\\overrightarrow{R}_x\\) $$\\overrightarrow{R}_x \\sim N(0, n/2)$$\nRx = [rx[nsteps] for rx in Rxs] plt.figure(figsize=(16,7)) sns.kdeplot(Rx, color=\u0026#39;red\u0026#39;) plt.hist(Rx, bins=50, density=True) plt.title(\u0026#39;Distribución de $R_x$\u0026#39;) plt.show() Distribución de \\(\\overrightarrow{R}_y\\) $$\\overrightarrow{R}_y \\sim N(0, n/2)$$\nRy = [ry[nsteps] for ry in Rys] plt.figure(figsize=(16,7)) sns.kdeplot(Ry, color=\u0026#39;red\u0026#39;) plt.hist(Ry, bins=50, density=True) plt.title(\u0026#39;Distribución de $R_y$\u0026#39;) plt.show() Distribución de \\(R_n^2\\) Sea \\(W= R_n^2 = \\overrightarrow{R}_x^2 + \\overrightarrow{R}_y^2\\), entonces la distribución viene dada por\n\\begin{equation}\rf_W(w) = \\frac{1}{n} \\exp\\{- \\frac{w}{n}\\}, \\ \\ \\ w\u0026gt;0\r\\end{equation}\nR2 = [r2[nsteps] for r2 in R2s] plt.figure(figsize=(16,7)) plt.hist(R2, bins=50, density=True) plt.title(\u0026#39;Distribución de $R_n^2$\u0026#39;) plt.show() Trayectoria del Caminante plt.figure(figsize=(14,10)) plt.plot(Rxs[1], Rys[1], \u0026#39;o\u0026#39;, color=\u0026#39;blue\u0026#39;, markersize=3) plt.plot(Rxs[1], Rys[1], color=\u0026#39;black\u0026#39;, linewidth=0.8) plt.title(\u0026#39;Pearson Random Walk\u0026#39;) plt.xlabel(\u0026#39;Time\u0026#39;) #mplcyberpunk.add_glow_effects() plt.show() ","date":1606875194,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1606875194,"objectID":"18ce86d090d91b9fde201c253e4013b7","permalink":"https://example.com/post/pearsonrandomwalk/","publishdate":"2020-12-01T21:13:14-05:00","relpermalink":"/post/pearsonrandomwalk/","section":"post","summary":"Pearson Random Walk simulation in Python.","tags":["Stochastic Processes","Statistics","Simulation"],"title":"Pearson Random Walk","type":"post"},{"authors":null,"categories":["Python"],"content":"import pandas as pd import numpy as np import matplotlib.pyplot as plt import seaborn as sns from random import sample #!pip install mplcyberpunk #import mplcyberpunk #plt.style.use(\u0026#34;cyberpunk\u0026#34;) sns.set() class StochasticSimulation: def __init__(self, steps=100, n_times=1, t=1): self.steps = steps self.n_times = n_times self.dt = t / steps def SimpleRandomWalk(self, p): # creating array rw = np.zeros( (self.n_times, self.steps+1)) # initiate the loop for j in range(rw.shape[1]-1): for i in range(rw.shape[0]): rw[i][j+1] = rw[i][j] + np.random.choice([-1,1], p=[1-p, p])#sample([-1,1], 1) df = pd.DataFrame(rw) return df def BrownianMotion(self): # creating array bm = np.zeros( (self.n_times, self.steps+1)) # initiate the loop for j in range(bm.shape[1]-1): for i in range(bm.shape[0]): bm[i][j+1] = bm[i][j] + np.random.normal(size=1) df = pd.DataFrame(bm) return df def BrownianBridge(self): # creating Brownian motion bm = np.zeros( (self.n_times, self.steps+1)) # initiate the loop for j in range(bm.shape[1]-1): for i in range(bm.shape[0]): bm[i][j+1] = bm[i][j] + np.random.normal(size=1) # array of Brownian Bridge bb = np.zeros( (self.n_times, self.steps+1)) # initiate the loop for j in range(bb.shape[1]-1): for i in range(bb.shape[0]): bb[i][j+1] = bm[i][j] + -(j/self.steps)*bm[i][self.steps] df = pd.DataFrame(bb) return df def BrownianMotionDrift(self, mu, sigma): # creating array bmd = np.zeros( (self.n_times, self.steps+1)) # initiate the loop for j in range(bmd.shape[1]-1): for i in range(bmd.shape[0]): bmd[i][j+1] = bmd[i][j] + mu*self.dt + sigma*np.sqrt(self.dt)*np.random.normal(size=1) df = pd.DataFrame(bmd) return df def GeometricBrownianMotion(self, S0, alpha, beta): # creating array gbm = np.zeros( (self.n_times, self.steps+1)) # initiate the loop for j in range(gbm.shape[1]): for i in range(gbm.shape[0]): if(j == 0): gbm[i][j] = S0 else: gbm[i][j] = gbm[i][j-1]*np.exp(np.random.normal(loc=(alpha - (beta**2)/2)*self.dt, scale=np.sqrt(self.dt)*beta, size=1)) df = pd.DataFrame(gbm) return df Movimiento Browniano Definición: Un proceso estocástico \\(\\{B(t), t\\geq 0\\}\\) se dice que es un movimiento Browniano si:\n1.- \\(B(0) = 0\\)\n2.- \\(\\{B(t), t\\geq 0\\}\\) tiene incrementos independientes y estacionarios.\n3.- Para \\(t\u0026gt;0\\), B(t) tiene distribución normal con media cero y varianza \\(t\\).\nMovimiento Browniano (1-D) # simulación steps = 10000 # pasos n = 100 # trayectorias bm_sim = StochasticSimulation(steps=steps, n_times=n).BrownianMotion() # gráfico plt.figure(figsize=(16,7)) for i in range(bm_sim.shape[0]): plt.plot(list(bm_sim.columns), bm_sim.iloc[i][:], color=\u0026#39;grey\u0026#39;) plt.title(\u0026#39;Brownian Motion Simulation: {} steps and {} paths\u0026#39;.format(steps, n)) plt.xlabel(\u0026#39;Time\u0026#39;) #mplcyberpunk.add_glow_effects() plt.show() Movimiento Browniano (2-D) # Brownian Bridge plt.figure(figsize=(16,10)) for i in range(bm_sim.shape[0]): plt.plot(bm_sim.iloc[0][:], bm_sim.iloc[1][:], color=\u0026#39;blue\u0026#39;, linewidth=0.4) plt.plot(bm_sim.iloc[0][:], bm_sim.iloc[1][:], \u0026#39;o\u0026#39;, color=\u0026#39;black\u0026#39;, markersize=0.4) plt.title(\u0026#39;Brownian Motion Simulation: {} steps\u0026#39;.format(steps)) plt.xlabel(\u0026#39;Time\u0026#39;) #mplcyberpunk.add_glow_effects() plt.show() Puente Browniano Definición: Un procesos estocástico \\(\\{X(t)= B(t) - \\frac{t}{T} B(T) , 0 \\leq t \\leq T \\}\\), es un puente Browniano si satisface las siguientes propiedades:\n1.- \\(X(0)=X(T)=0\\)\n2.- \\(X(t)\\) se distribuye como una normal con media cero y varianza \\(t(1-t/T)\\)\n$$E(X(t)) = 0$$, y $$Var(X(t)) = t(1-t/T)$$\n3.- \\(Cov(X(s), X(t)) = min(s, t) - \\frac{st}{T}\\)\nPuente Browniano (1-D) # simulación steps = 100000 # número de pasos n = 100 # número de trayectorias bm_sim = StochasticSimulation(steps=steps, n_times=n).BrownianBridge() # gráfico plt.figure(figsize=(16,7)) for i in range(bm_sim.shape[0]): plt.plot(list(bm_sim.columns), bm_sim.iloc[i][:], color=\u0026#39;grey\u0026#39;) plt.title(\u0026#39;Brownian Bridge Simulation: {} steps and {} paths\u0026#39;.format(steps, n)) plt.xlabel(\u0026#39;Time\u0026#39;) #mplcyberpunk.add_glow_effects() plt.show() Puente Browniano (2-D) # Brownian Bridge plt.figure(figsize=(16,10)) for i in range(bm_sim.shape[0]): plt.plot(bm_sim.iloc[0][:], bm_sim.iloc[1][:], color=\u0026#39;blue\u0026#39;, linewidth=0.4) plt.plot(bm_sim.iloc[0][:], bm_sim.iloc[1][:], \u0026#39;o\u0026#39;, color=\u0026#39;black\u0026#39;, markersize=0.4) plt.title(\u0026#39;Brownian Bridge Simulation: {} steps\u0026#39;.format(steps)) plt.xlabel(\u0026#39;Time\u0026#39;) #mplcyberpunk.add_glow_effects() plt.show() Caminata aleatoria simple Definición: La caminata aleatoria en \\(\\mathbb{Z}\\), es la más simple de todas, de ahí su nombre. \\(X_i\\) toma valores en \\(\\{−1,1\\}\\), y la caminata comienza en \\(S_n = 0\\) y está definida para valores enteros. Las probabilidades de ir a la derecha o a la izquierda se denotan como \\(P(X_i=1)\\) y \\(P(X_i=-1)\\), respectivamente, con las siguientes probabilidades para el caso de una caminata aleatoria simétrica:\n\\begin{equation*}\rP(X_i=1)=P(X_i=−1)=1/2\r\\end{equation*}\nConsiderando el caso más general, se tiene que el caminante puede ir a la derecha con probabilidad \\(p\\), y a la izquierda con probabilidad …","date":1606875194,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1606875194,"objectID":"84a876ba789bb7232be8d9ed2487fd98","permalink":"https://example.com/post/2020-12-01-r-rmarkdown/","publishdate":"2020-12-01T21:13:14-05:00","relpermalink":"/post/2020-12-01-r-rmarkdown/","section":"post","summary":"Simulation of some basic stochastic processes in Python such as simple random walk, Brownian motion, Brownian bridge, Brownian motion with drift and volatility, and Geometric Brownian motion.","tags":["Stochastic Processes","Statistics","Simulation"],"title":"Some Stochastic Models","type":"post"},{"authors":null,"categories":["R"],"content":"Introducción La caminata aleatoria en \\(\\mathbb{Z}\\), es la más simple de todas, de ahí su nombre. \\(X_1\\) toma valores en \\(\\{-1; 1\\}\\), y la caminata comienza en \\(0\\) y está definida para valores en \\(\\mathbb{Z}\\). Las probabilidades se denotan como:\n$$\\begin{equation}\rP(X_1 = 1) = P(X_1 = -1) = 1/2\r\\end{equation}$$\nConsiderando el caso más general, se tiene que\n$$\\begin{equation}\rP(X_1 = 1) = p \\ \\ y \\ \\ P(X_1 = -1) = 1 - p\r\\end{equation}$$\nVamos a obtener la probabilidad de que el caminante se encuentre en la posición \\(m\\) después de \\(N\\) pasos. Para \\(m \u0026lt; N\\) hay muchas maneras de empezar en \\(0\\) y pasar por \\(N\\) saltos a sitios vecinos más cercanos y terminar en \\(m\\). Sabemos que el número de pasos viene dado por la posición final más el número de pasos a la izquierda, es decir, \\(n_1 = m + n_2\\), y a parte sabemos que \\(n_1 + n_2 = N\\), solucionando para \\(n_1\\) y \\(n_2\\), se tiene\n$$\\begin{equation}\rn_1 = \\frac{1}{2} (N + m) \\\\\rn_2 = \\frac{1}{2} (N - m) \\\\\r\\end{equation}$$\nLa probabilidad de una secuencia de saltos a la izquierda y a la derecha es el producto de las probabilidades de los saltos individuales. Como los saltos individuales son independientes, todos los caminos que empiezan en \\(0\\) y terminan en \\(m\\) tienen la misma probabilidad global.\n$$\\begin{equation}\rp^{n_1} q^{n_2} = p^{\\frac{1}{2} (N + m)} q^{\\frac{1}{2} (N + m)}\r\\end{equation}$$\nEsta probabilidad debe multiplicarse por el número total de trayectorias con \\(n_1\\) pasos a la derecha y \\(n_2\\) pasos a la izquierda. Esto viene dado por el número de formas de poner \\(n_1\\) objetos de \\(N\\) en una caja y \\(n_2 = N - n_1\\) objetos en otra caja. El primer objeto se puede elegir de \\(N\\) maneras, el segundo de \\(N - 1\\) maneras y así sucesivamente. Por lo tanto, el número total de elección de \\(n_1\\) objetos es \\(N(N - 1)(N - 2)(N - n_1 - 1)\\). Pero los \\(n_1\\) objetos son idénticos y pueden disponerse en cualquier orden.\n$$\\begin{equation}\r\\frac{N!}{n_1! n_2!} = \\frac{N!}{n_1!(N-n_1)!}\r\\end{equation}$$\nLa probabilidad de estar en la posición m después de \\(N\\) saltos viene dada, por\n$$\\begin{equation}\rp(m, N) = \\frac{N!}{\\left(\\frac{N+m}{2}\\right)! \\left(\\frac{N-m}{2}\\right)!} p^{\\frac{1}{2} (N + m)} q^{\\frac{1}{2} (N - m)} \\end{equation}$$\nSi conocieramos la distribución de probabilidad podr?amos obtener todos los momentos. Note que la ecuación anterior se parece mucho a la distribución binomial, si consideramos el n?mero de pasos hacia la derecha como \\(n = (N +m)/2\\) podemos escribir\n$$\\begin{equation}\rp(n, N) = \\frac{N!}{n! (N-n)!} p^{n} q^{N - m} \\end{equation}$$\nSuponemos que ya conocemos los momentos de la distribución binomial, entonces\n$$\\begin{equation}\rE[n] = NP \\\\\rVar(n) = Npq\r\\end{equation}$$\nComo \\(n = (N + m)/2! \\rightarrow m = 2n - N\\), el valor esperado de la posición del caminante después de \\(N\\) pasos viene dada ahora por\n$$\\begin{eqnarray}\rE[m] \u0026amp; = \u0026amp; 2E[n] - N \\\\\r\u0026amp; = \u0026amp; 2Np - N \\\\\r\u0026amp; = \u0026amp; N(2p - 1)\r\\end{eqnarray}$$\ny la varianza viene dada por\n$$\\begin{eqnarray}\rVar[m] \u0026amp; = \u0026amp; 4Var(n) \\\\\r\u0026amp; = \u0026amp; 4Npq\r\\end{eqnarray}$$\nSimulación # Reading packages library(\u0026#34;ggplot2\u0026#34;) library(\u0026#34;dplyr\u0026#34;) library(\u0026#34;plotly\u0026#34;) library(\u0026#34;ggthemes\u0026#34;) library(\u0026#34;tidyr\u0026#34;) library(\u0026#34;stringr\u0026#34;) # Función para simular una caminata aleatoria simple simple.random.walk \u0026lt;- function(n.steps, n.sim, prob.r=0.5){ n \u0026lt;- n.steps a \u0026lt;- prob.r # movimiento x.left = -1 x.right = 1 # iteración Sn_mat \u0026lt;- matrix(0,ncol=n+1,nrow=n.sim) for(i in 1:n.sim){ for(j in 2:(n+1)){ step \u0026lt;- sample(c(x.left,x.right), 1, prob=c(1-a,a), replace=F) Sn_mat[i,j] \u0026lt;- Sn_mat[i,j-1] + step } } # names names \u0026lt;- sapply(1:(n+1),function(i) paste(\u0026#39;step\u0026#39;,i,sep=\u0026#39;\u0026#39;)) # data frame result_df \u0026lt;- data.frame(\u0026#39;sim\u0026#39;=sapply(1:n.sim, function(i) paste(\u0026#39;sim\u0026#39;,i,sep=\u0026#39;\u0026#39;)), \u0026#39;Sn\u0026#39;=Sn_mat) return(result_df) } Caminata aleatoria simple (1-D) Ejemplo 1: \\(p = 0.5\\) ####### Ejemplo: n.steps \u0026lt;- 10000 # número de pasos n.sim \u0026lt;- 1000 # número de trayectorias p \u0026lt;- 0.5 # probabilidad de moverse a la derecha df \u0026lt;- simple.random.walk(n.steps, n.sim, prob.r=p) ## trayectorias df_rw \u0026lt;- df %\u0026gt;% gather(key=\u0026#39;t\u0026#39;,value=\u0026#39;valor\u0026#39;,-sim) %\u0026gt;% mutate(t = as.numeric(substring(t,4,10))) %\u0026gt;% arrange(sim) # valores teóricos moments_rw \u0026lt;- data.frame(\u0026#39;t\u0026#39;=c(1:n.steps),\u0026#39;p\u0026#39;=p) %\u0026gt;% mutate(\u0026#39;mean\u0026#39;=t*(p-(1-p)), \u0026#39;sd_sup\u0026#39;=mean + 2*sqrt(4*t*p*(1-p)), \u0026#39;sd_inf\u0026#39;=mean - 2*sqrt(4*t*p*(1-p))) # gráfico p1 \u0026lt;- ggplot(df_rw,aes(x=t,y=valor,color=sim)) + geom_line() + geom_line(moments_rw, mapping=aes(x=t,y=mean),col=\u0026#39;red\u0026#39;,size=0.7) + geom_line(moments_rw, mapping=aes(x=t,y=sd_sup),col=\u0026#39;blue\u0026#39;,size=0.7,linetype = \u0026#34;dashed\u0026#34;) + geom_line(moments_rw, mapping=aes(x=t,y=sd_inf),col=\u0026#39;blue\u0026#39;,size=0.7,linetype = \u0026#34;dashed\u0026#34;) + scale_colour_grey(start = 0.2,end = 0.6) + theme(legend.position=\u0026#34;none\u0026#34;) + ggtitle(paste(n.sim,\u0026#34; trayectorias del camino aleatorio simple.\u0026#34;,sep=\u0026#39;\u0026#39;)) p1 Ejemplo 2: \\(p = 0.6\\) ####### Ejemplo n.steps \u0026lt;- 10000 # número de pasos n.sim \u0026lt;- 1000 # número de trayectorias p \u0026lt;- 0.6 # probabilidad de moverse a la derecha df \u0026lt;- simple.random.walk(n.steps, n.sim, …","date":1604283194,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1604283194,"objectID":"56c11e9172f940c4a607cd6b6f41897c","permalink":"https://example.com/post/simplerandomwalk/","publishdate":"2020-11-01T21:13:14-05:00","relpermalink":"/post/simplerandomwalk/","section":"post","summary":"Simple Random Walk simulation in Python.","tags":["Stochastic Processes","Statistics","Simulation"],"title":"Simple Random Walk","type":"post"},{"authors":["Julio Cesar Martinez"],"categories":null,"content":" Create your slides in Markdown - click the Slides button to check out the example. Supplementary notes can be added here, including code, math, and images.\n","date":1554595200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1554595200,"objectID":"557dc08fd4b672a0c08e0a8cf0c9ff7d","permalink":"https://example.com/publication/preprint/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/preprint/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":["Source Themes"],"title":"An example preprint / working paper","type":"publication"},{"authors":["Julio Cesar Martinez"],"categories":null,"content":" Create your slides in Markdown - click the Slides button to check out the example. Supplementary notes can be added here, including code, math, and images.\n","date":1554595200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1554595200,"objectID":"a11cec9eddb5514252e7d98f8c39c0a1","permalink":"https://example.com/publication/publication/preprint/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/publication/preprint/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":["Source Themes"],"title":"An example preprint / working paper","type":"publication"},{"authors":[],"categories":[],"content":"Create slides in Markdown with Wowchemy Wowchemy | Documentation\nFeatures Efficiently write slides in Markdown 3-in-1: Create, Present, and Publish your slides Supports speaker notes Mobile friendly slides Controls Next: Right Arrow or Space Previous: Left Arrow Start: Home Finish: End Overview: Esc Speaker notes: S Fullscreen: F Zoom: Alt + Click PDF Export Code Highlighting Inline code: variable\nCode block:\nporridge = \u0026#34;blueberry\u0026#34; if porridge == \u0026#34;blueberry\u0026#34;: print(\u0026#34;Eating...\u0026#34;) Math In-line math: $x + y = z$\nBlock math:\n$$ f\\left( x \\right) = ;\\frac{{2\\left( {x + 4} \\right)\\left( {x - 4} \\right)}}{{\\left( {x + 4} \\right)\\left( {x + 1} \\right)}} $$\nFragments Make content appear incrementally\n{{% fragment %}} One {{% /fragment %}} {{% fragment %}} **Two** {{% /fragment %}} {{% fragment %}} Three {{% /fragment %}} Press Space to play!\nOne Two Three A fragment can accept two optional parameters:\nclass: use a custom style (requires definition in custom CSS) weight: sets the order in which a fragment appears Speaker Notes Add speaker notes to your presentation\n{{% speaker_note %}} - Only the speaker can read these notes - Press `S` key to view {{% /speaker_note %}} Press the S key to view the speaker notes!\nOnly the speaker can read these notes Press S key to view Themes black: Black background, white text, blue links (default) white: White background, black text, blue links league: Gray background, white text, blue links beige: Beige background, dark text, brown links sky: Blue background, thin dark text, blue links night: Black background, thick white text, orange links serif: Cappuccino background, gray text, brown links simple: White background, black text, blue links solarized: Cream-colored background, dark green text, blue links Custom Slide Customize the slide style and background\n{{\u0026lt; slide background-image=\u0026#34;/media/boards.jpg\u0026#34; \u0026gt;}} {{\u0026lt; slide background-color=\u0026#34;#0000FF\u0026#34; \u0026gt;}} {{\u0026lt; slide class=\u0026#34;my-style\u0026#34; \u0026gt;}} Custom CSS Example Let’s make headers navy colored.\nCreate assets/css/reveal_custom.css with:\n.reveal section h1, .reveal section h2, .reveal section h3 { color: navy; } Questions? Ask\nDocumentation\n","date":1549324800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1549324800,"objectID":"0e6de1a61aa83269ff13324f3167c1a9","permalink":"https://example.com/slides/example/","publishdate":"2019-02-05T00:00:00Z","relpermalink":"/slides/example/","section":"slides","summary":"An introduction to using Wowchemy's Slides feature.","tags":[],"title":"Slides","type":"slides"},{"authors":null,"categories":null,"content":"","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1461715200,"objectID":"e5c78c036ed890f7e738d632374c6dbb","permalink":"https://example.com/project/project/example/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"/project/project/example/","section":"project","summary":".","tags":null,"title":"","type":"project"},{"authors":null,"categories":null,"content":"","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1461715200,"objectID":"d73028784db2f8b41af35400be8390cb","permalink":"https://example.com/project/project/external-project/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"/project/project/external-project/","section":"project","summary":"Recently Published.","tags":["Demo"],"title":"Rpubs","type":"project"},{"authors":["Julio Cesar Martinez","Robert Ford"],"categories":null,"content":" Click the Cite button above to demo the feature to enable visitors to import publication metadata into their reference management software. Create your slides in Markdown - click the Slides button to check out the example. Supplementary notes can be added here, including code, math, and images.\n","date":1441065600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1441065600,"objectID":"966884cc0d8ac9e31fab966c4534e973","permalink":"https://example.com/publication/journal-article/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/journal-article/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":["Source Themes"],"title":"An example journal article","type":"publication"},{"authors":["Julio Cesar Martinez","Robert Ford"],"categories":null,"content":" Click the Cite button above to demo the feature to enable visitors to import publication metadata into their reference management software. Create your slides in Markdown - click the Slides button to check out the example. Supplementary notes can be added here, including code, math, and images.\n","date":1441065600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1441065600,"objectID":"16dadfff92ee67b595e0358f9700b9fd","permalink":"https://example.com/publication/publication/journal-article/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/publication/journal-article/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":["Source Themes"],"title":"An example journal article","type":"publication"},{"authors":["Julio Cesar Martinez","Robert Ford"],"categories":null,"content":" Click the Cite button above to demo the feature to enable visitors to import publication metadata into their reference management software. Create your slides in Markdown - click the Slides button to check out the example. Supplementary notes can be added here, including code, math, and images.\n","date":1372636800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1372636800,"objectID":"69425fb10d4db090cfbd46854715582c","permalink":"https://example.com/publication/conference-paper/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/conference-paper/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":[],"title":"An example conference paper","type":"publication"},{"authors":["Julio Cesar Martinez","Robert Ford"],"categories":null,"content":" Click the Cite button above to demo the feature to enable visitors to import publication metadata into their reference management software. Create your slides in Markdown - click the Slides button to check out the example. Supplementary notes can be added here, including code, math, and images.\n","date":1372636800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1372636800,"objectID":"7f10b6318d77b0d9f16d4d178f6c4dac","permalink":"https://example.com/publication/publication/conference-paper/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/publication/conference-paper/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":[],"title":"An example conference paper","type":"publication"}]